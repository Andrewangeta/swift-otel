// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/trace/v1/trace.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// A collection of InstrumentationLibrarySpans from a Resource.
struct Opentelemetry_Proto_Trace_V1_ResourceSpans {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The resource for the spans in this message.
    /// If this field is not set then no resource info is known.
    var resource: Opentelemetry_Proto_Resource_V1_Resource {
        get { _resource ?? Opentelemetry_Proto_Resource_V1_Resource() }
        set { _resource = newValue }
    }

    /// Returns true if `resource` has been explicitly set.
    var hasResource: Bool { self._resource != nil }
    /// Clears the value of `resource`. Subsequent reads from it will return its default value.
    mutating func clearResource() { _resource = nil }

    /// A list of InstrumentationLibrarySpans that originate from a resource.
    var instrumentationLibrarySpans: [Opentelemetry_Proto_Trace_V1_InstrumentationLibrarySpans] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _resource: Opentelemetry_Proto_Resource_V1_Resource?
}

/// A collection of Spans produced by an InstrumentationLibrary.
struct Opentelemetry_Proto_Trace_V1_InstrumentationLibrarySpans {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The instrumentation library information for the spans in this message.
    /// Semantically when InstrumentationLibrary isn't set, it is equivalent with
    /// an empty instrumentation library name (unknown).
    var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
        get { _instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary() }
        set { _instrumentationLibrary = newValue }
    }

    /// Returns true if `instrumentationLibrary` has been explicitly set.
    var hasInstrumentationLibrary: Bool { self._instrumentationLibrary != nil }
    /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
    mutating func clearInstrumentationLibrary() { _instrumentationLibrary = nil }

    /// A list of Spans that originate from an instrumentation library.
    var spans: [Opentelemetry_Proto_Trace_V1_Span] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary?
}

/// Span represents a single operation within a trace. Spans can be
/// nested to form a trace tree. Spans may also be linked to other spans
/// from the same or different trace and form graphs. Often, a trace
/// contains a root span that describes the end-to-end latency, and one
/// or more subspans for its sub-operations. A trace can also contain
/// multiple root spans, or none at all. Spans do not need to be
/// contiguous - there may be gaps or overlaps between spans in a trace.
///
/// The next available field id is 17.
struct Opentelemetry_Proto_Trace_V1_Span {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier for a trace. All spans from the same trace share
    /// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes
    /// is considered invalid.
    ///
    /// This field is semantically required. Receiver should generate new
    /// random trace_id if empty or invalid trace_id was received.
    ///
    /// This field is required.
    var traceID: Data {
        get { _storage._traceID }
        set { _uniqueStorage()._traceID = newValue }
    }

    /// A unique identifier for a span within a trace, assigned when the span
    /// is created. The ID is an 8-byte array. An ID with all zeroes is considered
    /// invalid.
    ///
    /// This field is semantically required. Receiver should generate new
    /// random span_id if empty or invalid span_id was received.
    ///
    /// This field is required.
    var spanID: Data {
        get { _storage._spanID }
        set { _uniqueStorage()._spanID = newValue }
    }

    /// trace_state conveys information about request position in multiple distributed tracing graphs.
    /// It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
    /// See also https://github.com/w3c/distributed-tracing for more details about this field.
    var traceState: String {
        get { _storage._traceState }
        set { _uniqueStorage()._traceState = newValue }
    }

    /// The `span_id` of this span's parent span. If this is a root span, then this
    /// field must be empty. The ID is an 8-byte array.
    var parentSpanID: Data {
        get { _storage._parentSpanID }
        set { _uniqueStorage()._parentSpanID = newValue }
    }

    /// A description of the span's operation.
    ///
    /// For example, the name can be a qualified method name or a file name
    /// and a line number where the operation is called. A best practice is to use
    /// the same display name at the same call point in an application.
    /// This makes it easier to correlate spans in different traces.
    ///
    /// This field is semantically required to be set to non-empty string.
    /// When null or empty string received - receiver may use string "name"
    /// as a replacement. There might be smarted algorithms implemented by
    /// receiver to fix the empty span name.
    ///
    /// This field is required.
    var name: String {
        get { _storage._name }
        set { _uniqueStorage()._name = newValue }
    }

    /// Distinguishes between spans generated in a particular context. For example,
    /// two spans with the same name may be distinguished using `CLIENT` (caller)
    /// and `SERVER` (callee) to identify queueing latency associated with the span.
    var kind: Opentelemetry_Proto_Trace_V1_Span.SpanKind {
        get { _storage._kind }
        set { _uniqueStorage()._kind = newValue }
    }

    /// start_time_unix_nano is the start time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution starts. On the server side, this
    /// is the time when the server's application handler starts running.
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    ///
    /// This field is semantically required and it is expected that end_time >= start_time.
    var startTimeUnixNano: UInt64 {
        get { _storage._startTimeUnixNano }
        set { _uniqueStorage()._startTimeUnixNano = newValue }
    }

    /// end_time_unix_nano is the end time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution ends. On the server side, this
    /// is the time when the server application handler stops running.
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    ///
    /// This field is semantically required and it is expected that end_time >= start_time.
    var endTimeUnixNano: UInt64 {
        get { _storage._endTimeUnixNano }
        set { _uniqueStorage()._endTimeUnixNano = newValue }
    }

    /// attributes is a collection of key/value pairs. The value can be a string,
    /// an integer, a double or the Boolean values `true` or `false`. Note, global attributes
    /// like server name can be set using the resource API. Examples of attributes:
    ///
    ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
    ///     "/http/server_latency": 300
    ///     "abc.com/myattribute": true
    ///     "abc.com/score": 10.239
    var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] {
        get { _storage._attributes }
        set { _uniqueStorage()._attributes = newValue }
    }

    /// dropped_attributes_count is the number of attributes that were discarded. Attributes
    /// can be discarded because their keys are too long or because there are too many
    /// attributes. If this value is 0, then no attributes were dropped.
    var droppedAttributesCount: UInt32 {
        get { _storage._droppedAttributesCount }
        set { _uniqueStorage()._droppedAttributesCount = newValue }
    }

    /// events is a collection of Event items.
    var events: [Opentelemetry_Proto_Trace_V1_Span.Event] {
        get { _storage._events }
        set { _uniqueStorage()._events = newValue }
    }

    /// dropped_events_count is the number of dropped events. If the value is 0, then no
    /// events were dropped.
    var droppedEventsCount: UInt32 {
        get { _storage._droppedEventsCount }
        set { _uniqueStorage()._droppedEventsCount = newValue }
    }

    /// links is a collection of Links, which are references from this span to a span
    /// in the same or different trace.
    var links: [Opentelemetry_Proto_Trace_V1_Span.Link] {
        get { _storage._links }
        set { _uniqueStorage()._links = newValue }
    }

    /// dropped_links_count is the number of dropped links after the maximum size was
    /// enforced. If this value is 0, then no links were dropped.
    var droppedLinksCount: UInt32 {
        get { _storage._droppedLinksCount }
        set { _uniqueStorage()._droppedLinksCount = newValue }
    }

    /// An optional final status for this span. Semantically when Status isn't set, it means
    /// span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
    var status: Opentelemetry_Proto_Trace_V1_Status {
        get { _storage._status ?? Opentelemetry_Proto_Trace_V1_Status() }
        set { _uniqueStorage()._status = newValue }
    }

    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool { _storage._status != nil }
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() { _uniqueStorage()._status = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// SpanKind is the type of span. Can be used to specify additional relationships between spans
    /// in addition to a parent/child relationship.
    enum SpanKind: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// Unspecified. Do NOT use as default.
        /// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
        case unspecified // = 0

        /// Indicates that the span represents an internal operation within an application,
        /// as opposed to an operation happening at the boundaries. Default value.
        case `internal` // = 1

        /// Indicates that the span covers server-side handling of an RPC or other
        /// remote network request.
        case server // = 2

        /// Indicates that the span describes a request to some remote service.
        case client // = 3

        /// Indicates that the span describes a producer sending a message to a broker.
        /// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
        /// between producer and consumer spans. A PRODUCER span ends when the message was accepted
        /// by the broker while the logical processing of the message might span a much longer time.
        case producer // = 4

        /// Indicates that the span describes consumer receiving a message from a broker.
        /// Like the PRODUCER kind, there is often no direct critical path latency relationship
        /// between producer and consumer spans.
        case consumer // = 5
        case UNRECOGNIZED(Int)

        init() {
            self = .unspecified
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .internal
            case 2: self = .server
            case 3: self = .client
            case 4: self = .producer
            case 5: self = .consumer
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unspecified: return 0
            case .internal: return 1
            case .server: return 2
            case .client: return 3
            case .producer: return 4
            case .consumer: return 5
            case .UNRECOGNIZED(let i): return i
            }
        }
    }

    /// Event is a time-stamped annotation of the span, consisting of user-supplied
    /// text description and key-value pairs.
    struct Event {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// time_unix_nano is the time the event occurred.
        var timeUnixNano: UInt64 = 0

        /// name of the event.
        /// This field is semantically required to be set to non-empty string.
        var name = String()

        /// attributes is a collection of attribute key/value pairs on the event.
        var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

        /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
        /// then no attributes were dropped.
        var droppedAttributesCount: UInt32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    /// A pointer from the current span to another span in the same trace or in a
    /// different trace. For example, this can be used in batching operations,
    /// where a single batch handler processes multiple requests from different
    /// traces or when the handler receives a request from a different project.
    struct Link {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// A unique identifier of a trace that this linked span is part of. The ID is a
        /// 16-byte array.
        var traceID = Data()

        /// A unique identifier for the linked span. The ID is an 8-byte array.
        var spanID = Data()

        /// The trace_state associated with the link.
        var traceState = String()

        /// attributes is a collection of attribute key/value pairs on the link.
        var attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []

        /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
        /// then no attributes were dropped.
        var droppedAttributesCount: UInt32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}

    private var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Opentelemetry_Proto_Trace_V1_Span.SpanKind: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Opentelemetry_Proto_Trace_V1_Span.SpanKind] = [
        .unspecified,
        .internal,
        .server,
        .client,
        .producer,
        .consumer,
    ]
}

#endif // swift(>=4.2)

/// The Status type defines a logical error model that is suitable for different
/// programming environments, including REST APIs and RPC APIs.
struct Opentelemetry_Proto_Trace_V1_Status {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The deprecated status code. This is an optional field.
    ///
    /// This field is deprecated and is replaced by the `code` field below. See backward
    /// compatibility notes below. According to our stability guarantees this field
    /// will be removed in 12 months, on Oct 22, 2021. All usage of old senders and
    /// receivers that do not understand the `code` field MUST be phased out by then.
    var deprecatedCode: Opentelemetry_Proto_Trace_V1_Status.DeprecatedStatusCode = .ok

    /// A developer-facing human readable error message.
    var message = String()

    /// The status code.
    var code: Opentelemetry_Proto_Trace_V1_Status.StatusCode = .unset

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum DeprecatedStatusCode: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case ok // = 0
        case cancelled // = 1
        case unknownError // = 2
        case invalidArgument // = 3
        case deadlineExceeded // = 4
        case notFound // = 5
        case alreadyExists // = 6
        case permissionDenied // = 7
        case resourceExhausted // = 8
        case failedPrecondition // = 9
        case aborted // = 10
        case outOfRange // = 11
        case unimplemented // = 12
        case internalError // = 13
        case unavailable // = 14
        case dataLoss // = 15
        case unauthenticated // = 16
        case UNRECOGNIZED(Int)

        init() {
            self = .ok
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .ok
            case 1: self = .cancelled
            case 2: self = .unknownError
            case 3: self = .invalidArgument
            case 4: self = .deadlineExceeded
            case 5: self = .notFound
            case 6: self = .alreadyExists
            case 7: self = .permissionDenied
            case 8: self = .resourceExhausted
            case 9: self = .failedPrecondition
            case 10: self = .aborted
            case 11: self = .outOfRange
            case 12: self = .unimplemented
            case 13: self = .internalError
            case 14: self = .unavailable
            case 15: self = .dataLoss
            case 16: self = .unauthenticated
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .ok: return 0
            case .cancelled: return 1
            case .unknownError: return 2
            case .invalidArgument: return 3
            case .deadlineExceeded: return 4
            case .notFound: return 5
            case .alreadyExists: return 6
            case .permissionDenied: return 7
            case .resourceExhausted: return 8
            case .failedPrecondition: return 9
            case .aborted: return 10
            case .outOfRange: return 11
            case .unimplemented: return 12
            case .internalError: return 13
            case .unavailable: return 14
            case .dataLoss: return 15
            case .unauthenticated: return 16
            case .UNRECOGNIZED(let i): return i
            }
        }
    }

    /// For the semantics of status codes see
    /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
    enum StatusCode: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// The default status.
        case unset // = 0

        /// The Span has been validated by an Application developers or Operator to have
        /// completed successfully.
        case ok // = 1

        /// The Span contains an error.
        case error // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .unset
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unset
            case 1: self = .ok
            case 2: self = .error
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .unset: return 0
            case .ok: return 1
            case .error: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }
    }

    init() {}
}

#if swift(>=4.2)

extension Opentelemetry_Proto_Trace_V1_Status.DeprecatedStatusCode: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Opentelemetry_Proto_Trace_V1_Status.DeprecatedStatusCode] = [
        .ok,
        .cancelled,
        .unknownError,
        .invalidArgument,
        .deadlineExceeded,
        .notFound,
        .alreadyExists,
        .permissionDenied,
        .resourceExhausted,
        .failedPrecondition,
        .aborted,
        .outOfRange,
        .unimplemented,
        .internalError,
        .unavailable,
        .dataLoss,
        .unauthenticated,
    ]
}

extension Opentelemetry_Proto_Trace_V1_Status.StatusCode: CaseIterable {
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Opentelemetry_Proto_Trace_V1_Status.StatusCode] = [
        .unset,
        .ok,
        .error,
    ]
}

#endif // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "opentelemetry.proto.trace.v1"

extension Opentelemetry_Proto_Trace_V1_ResourceSpans: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ResourceSpans"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "resource"),
        2: .standard(proto: "instrumentation_library_spans"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.instrumentationLibrarySpans) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _resource {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !instrumentationLibrarySpans.isEmpty {
            try visitor.visitRepeatedMessageField(value: instrumentationLibrarySpans, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_ResourceSpans, rhs: Opentelemetry_Proto_Trace_V1_ResourceSpans) -> Bool {
        if lhs._resource != rhs._resource { return false }
        if lhs.instrumentationLibrarySpans != rhs.instrumentationLibrarySpans { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_InstrumentationLibrarySpans: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".InstrumentationLibrarySpans"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "instrumentation_library"),
        2: .same(proto: "spans"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._instrumentationLibrary) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if let v = _instrumentationLibrary {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !spans.isEmpty {
            try visitor.visitRepeatedMessageField(value: spans, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_InstrumentationLibrarySpans, rhs: Opentelemetry_Proto_Trace_V1_InstrumentationLibrarySpans) -> Bool {
        if lhs._instrumentationLibrary != rhs._instrumentationLibrary { return false }
        if lhs.spans != rhs.spans { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Span"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "trace_id"),
        2: .standard(proto: "span_id"),
        3: .standard(proto: "trace_state"),
        4: .standard(proto: "parent_span_id"),
        5: .same(proto: "name"),
        6: .same(proto: "kind"),
        7: .standard(proto: "start_time_unix_nano"),
        8: .standard(proto: "end_time_unix_nano"),
        9: .same(proto: "attributes"),
        10: .standard(proto: "dropped_attributes_count"),
        11: .same(proto: "events"),
        12: .standard(proto: "dropped_events_count"),
        13: .same(proto: "links"),
        14: .standard(proto: "dropped_links_count"),
        15: .same(proto: "status"),
    ]

    fileprivate class _StorageClass {
        var _traceID = Data()
        var _spanID = Data()
        var _traceState = String()
        var _parentSpanID = Data()
        var _name = String()
        var _kind: Opentelemetry_Proto_Trace_V1_Span.SpanKind = .unspecified
        var _startTimeUnixNano: UInt64 = 0
        var _endTimeUnixNano: UInt64 = 0
        var _attributes: [Opentelemetry_Proto_Common_V1_KeyValue] = []
        var _droppedAttributesCount: UInt32 = 0
        var _events: [Opentelemetry_Proto_Trace_V1_Span.Event] = []
        var _droppedEventsCount: UInt32 = 0
        var _links: [Opentelemetry_Proto_Trace_V1_Span.Link] = []
        var _droppedLinksCount: UInt32 = 0
        var _status: Opentelemetry_Proto_Trace_V1_Status?

        static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _traceID = source._traceID
            _spanID = source._spanID
            _traceState = source._traceState
            _parentSpanID = source._parentSpanID
            _name = source._name
            _kind = source._kind
            _startTimeUnixNano = source._startTimeUnixNano
            _endTimeUnixNano = source._endTimeUnixNano
            _attributes = source._attributes
            _droppedAttributesCount = source._droppedAttributesCount
            _events = source._events
            _droppedEventsCount = source._droppedEventsCount
            _links = source._links
            _droppedLinksCount = source._droppedLinksCount
            _status = source._status
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularBytesField(value: &_storage._traceID) }()
                case 2: try { try decoder.decodeSingularBytesField(value: &_storage._spanID) }()
                case 3: try { try decoder.decodeSingularStringField(value: &_storage._traceState) }()
                case 4: try { try decoder.decodeSingularBytesField(value: &_storage._parentSpanID) }()
                case 5: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
                case 6: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
                case 7: try { try decoder.decodeSingularFixed64Field(value: &_storage._startTimeUnixNano) }()
                case 8: try { try decoder.decodeSingularFixed64Field(value: &_storage._endTimeUnixNano) }()
                case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._attributes) }()
                case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedAttributesCount) }()
                case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._events) }()
                case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedEventsCount) }()
                case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
                case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._droppedLinksCount) }()
                case 15: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
                default: break
                }
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._traceID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._traceID, fieldNumber: 1)
            }
            if !_storage._spanID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._spanID, fieldNumber: 2)
            }
            if !_storage._traceState.isEmpty {
                try visitor.visitSingularStringField(value: _storage._traceState, fieldNumber: 3)
            }
            if !_storage._parentSpanID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._parentSpanID, fieldNumber: 4)
            }
            if !_storage._name.isEmpty {
                try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
            }
            if _storage._kind != .unspecified {
                try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 6)
            }
            if _storage._startTimeUnixNano != 0 {
                try visitor.visitSingularFixed64Field(value: _storage._startTimeUnixNano, fieldNumber: 7)
            }
            if _storage._endTimeUnixNano != 0 {
                try visitor.visitSingularFixed64Field(value: _storage._endTimeUnixNano, fieldNumber: 8)
            }
            if !_storage._attributes.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._attributes, fieldNumber: 9)
            }
            if _storage._droppedAttributesCount != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._droppedAttributesCount, fieldNumber: 10)
            }
            if !_storage._events.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._events, fieldNumber: 11)
            }
            if _storage._droppedEventsCount != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._droppedEventsCount, fieldNumber: 12)
            }
            if !_storage._links.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 13)
            }
            if _storage._droppedLinksCount != 0 {
                try visitor.visitSingularUInt32Field(value: _storage._droppedLinksCount, fieldNumber: 14)
            }
            if let v = _storage._status {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_Span, rhs: Opentelemetry_Proto_Trace_V1_Span) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._traceID != rhs_storage._traceID { return false }
                if _storage._spanID != rhs_storage._spanID { return false }
                if _storage._traceState != rhs_storage._traceState { return false }
                if _storage._parentSpanID != rhs_storage._parentSpanID { return false }
                if _storage._name != rhs_storage._name { return false }
                if _storage._kind != rhs_storage._kind { return false }
                if _storage._startTimeUnixNano != rhs_storage._startTimeUnixNano { return false }
                if _storage._endTimeUnixNano != rhs_storage._endTimeUnixNano { return false }
                if _storage._attributes != rhs_storage._attributes { return false }
                if _storage._droppedAttributesCount != rhs_storage._droppedAttributesCount { return false }
                if _storage._events != rhs_storage._events { return false }
                if _storage._droppedEventsCount != rhs_storage._droppedEventsCount { return false }
                if _storage._links != rhs_storage._links { return false }
                if _storage._droppedLinksCount != rhs_storage._droppedLinksCount { return false }
                if _storage._status != rhs_storage._status { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_Span.SpanKind: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SPAN_KIND_UNSPECIFIED"),
        1: .same(proto: "SPAN_KIND_INTERNAL"),
        2: .same(proto: "SPAN_KIND_SERVER"),
        3: .same(proto: "SPAN_KIND_CLIENT"),
        4: .same(proto: "SPAN_KIND_PRODUCER"),
        5: .same(proto: "SPAN_KIND_CONSUMER"),
    ]
}

extension Opentelemetry_Proto_Trace_V1_Span.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Opentelemetry_Proto_Trace_V1_Span.protoMessageName + ".Event"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "time_unix_nano"),
        2: .same(proto: "name"),
        3: .same(proto: "attributes"),
        4: .standard(proto: "dropped_attributes_count"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
            case 4: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if timeUnixNano != 0 {
            try visitor.visitSingularFixed64Field(value: timeUnixNano, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !attributes.isEmpty {
            try visitor.visitRepeatedMessageField(value: attributes, fieldNumber: 3)
        }
        if droppedAttributesCount != 0 {
            try visitor.visitSingularUInt32Field(value: droppedAttributesCount, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_Span.Event, rhs: Opentelemetry_Proto_Trace_V1_Span.Event) -> Bool {
        if lhs.timeUnixNano != rhs.timeUnixNano { return false }
        if lhs.name != rhs.name { return false }
        if lhs.attributes != rhs.attributes { return false }
        if lhs.droppedAttributesCount != rhs.droppedAttributesCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_Span.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Opentelemetry_Proto_Trace_V1_Span.protoMessageName + ".Link"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "trace_id"),
        2: .standard(proto: "span_id"),
        3: .standard(proto: "trace_state"),
        4: .same(proto: "attributes"),
        5: .standard(proto: "dropped_attributes_count"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
            case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.traceState) }()
            case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
            case 5: try { try decoder.decodeSingularUInt32Field(value: &self.droppedAttributesCount) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !traceID.isEmpty {
            try visitor.visitSingularBytesField(value: traceID, fieldNumber: 1)
        }
        if !spanID.isEmpty {
            try visitor.visitSingularBytesField(value: spanID, fieldNumber: 2)
        }
        if !traceState.isEmpty {
            try visitor.visitSingularStringField(value: traceState, fieldNumber: 3)
        }
        if !attributes.isEmpty {
            try visitor.visitRepeatedMessageField(value: attributes, fieldNumber: 4)
        }
        if droppedAttributesCount != 0 {
            try visitor.visitSingularUInt32Field(value: droppedAttributesCount, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_Span.Link, rhs: Opentelemetry_Proto_Trace_V1_Span.Link) -> Bool {
        if lhs.traceID != rhs.traceID { return false }
        if lhs.spanID != rhs.spanID { return false }
        if lhs.traceState != rhs.traceState { return false }
        if lhs.attributes != rhs.attributes { return false }
        if lhs.droppedAttributesCount != rhs.droppedAttributesCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Status"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "deprecated_code"),
        2: .same(proto: "message"),
        3: .same(proto: "code"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.deprecatedCode) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self.code) }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if deprecatedCode != .ok {
            try visitor.visitSingularEnumField(value: deprecatedCode, fieldNumber: 1)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 2)
        }
        if code != .unset {
            try visitor.visitSingularEnumField(value: code, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Opentelemetry_Proto_Trace_V1_Status, rhs: Opentelemetry_Proto_Trace_V1_Status) -> Bool {
        if lhs.deprecatedCode != rhs.deprecatedCode { return false }
        if lhs.message != rhs.message { return false }
        if lhs.code != rhs.code { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Opentelemetry_Proto_Trace_V1_Status.DeprecatedStatusCode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DEPRECATED_STATUS_CODE_OK"),
        1: .same(proto: "DEPRECATED_STATUS_CODE_CANCELLED"),
        2: .same(proto: "DEPRECATED_STATUS_CODE_UNKNOWN_ERROR"),
        3: .same(proto: "DEPRECATED_STATUS_CODE_INVALID_ARGUMENT"),
        4: .same(proto: "DEPRECATED_STATUS_CODE_DEADLINE_EXCEEDED"),
        5: .same(proto: "DEPRECATED_STATUS_CODE_NOT_FOUND"),
        6: .same(proto: "DEPRECATED_STATUS_CODE_ALREADY_EXISTS"),
        7: .same(proto: "DEPRECATED_STATUS_CODE_PERMISSION_DENIED"),
        8: .same(proto: "DEPRECATED_STATUS_CODE_RESOURCE_EXHAUSTED"),
        9: .same(proto: "DEPRECATED_STATUS_CODE_FAILED_PRECONDITION"),
        10: .same(proto: "DEPRECATED_STATUS_CODE_ABORTED"),
        11: .same(proto: "DEPRECATED_STATUS_CODE_OUT_OF_RANGE"),
        12: .same(proto: "DEPRECATED_STATUS_CODE_UNIMPLEMENTED"),
        13: .same(proto: "DEPRECATED_STATUS_CODE_INTERNAL_ERROR"),
        14: .same(proto: "DEPRECATED_STATUS_CODE_UNAVAILABLE"),
        15: .same(proto: "DEPRECATED_STATUS_CODE_DATA_LOSS"),
        16: .same(proto: "DEPRECATED_STATUS_CODE_UNAUTHENTICATED"),
    ]
}

extension Opentelemetry_Proto_Trace_V1_Status.StatusCode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "STATUS_CODE_UNSET"),
        1: .same(proto: "STATUS_CODE_OK"),
        2: .same(proto: "STATUS_CODE_ERROR"),
    ]
}
